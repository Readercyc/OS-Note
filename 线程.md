
# 线程

##进程
1. 进程拥有资源的所有权。进程是**可拥有资源**的独立单位
2. 调度
3. 目的：为了多个程序能够并发执行，以提高资源利用
4. 任一时刻只有一个执行控制流，有可能会互斥

##线程（轻量级的进程）
1. 优化并发
2. 设计出多条控制流
3. **多控制流可以并行**（并发性）
4. **切换不需要进程调度**
5. 可以与内存直接通信
6. 所有线程共享**但不拥有**进程的状态和资源(共享性）
7. 同样拥有状态（派生，解除阻塞，阻塞，结束...）
8. 线程（或:只有一个线程的进程）是操作系统中的**调度和分派的基本单位**

**两者并不矛盾**

---
##多线程下的进程
- 进程被定义为**资源分配的基本单位**
- 一个进程包含一个或多个线程，如果只包含一个，本质上没有差别
- 多线程共享访问近程的内存空间和资源（进程控制块，用户地址空间）

---
##线程的实现
1. 用户级线程（**无内核干预**）
- 线程管理的所有工作由应用程序完成，内核感受不到其存在
- **线程切换不需要转换到内核空间，节省切换的开销**
- 调度算法可以根据进程进行调整
- 与操作系统平台无关
- 许多系统调用会引起阻塞
- 多线程应用不能利用多处理机技术进行多重处理（内核一次只为一个每个进程分配一个处理器，也就是每次只有一个线程处于运行态）

2. 内核级线程（**全部由内核干预**）
    - 所有工作都由内核完成，应用程序不参与
    - 内核能一次分配多个处理机，让多线程并行执行
    - 减少阻塞（就算一个阻塞，也可以分配别的处理机）
    - 用户态切换内核态频繁，开销较大

3. 组合使用
    - 互补，克服各自的不足

---
#互斥与同步
   
##处理多线程的方式（核心：并发）
- 多道程序设计技术
- 多处理技术
- 分布式处理技术

##术语
1. 临界区（Critical section)
    - 是临界资源的程序代码，进程将在此代码中访问共享的资源，当另一个进程已经在该代码中执行时，则该进程不能再这段代码中执行
    - 临界资源：每次只能被一个进程访问的资源
    - 多个进程要共享临界区
        1. 空闲让进
        2. 忙则等待
        3. 有限等待（限定有限时间要拿到）
        4. 让权等待
2. 竞争（Competition）
    - 多个进程在访问一个共享数据时，结果依赖于它们执行的相对时间
3. 同步（synchronization）
    - 系统中的有一些相互合作，协同工作的进程，他们之间的相互联系称为同步
4. 互斥（Mutual exclusion）
    - 共同争抢同一共享资源
    - 当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何资源

5. 死锁（dead lock）
    - 两个及其以上的进程都因为等待对方的空间而互不相让时即为死锁（让权等待原则解决）
6. 饥饿
    - 一个可执行的进程被调度程序无限循环忽视而不能执行（有限等待原则来解决）

##两种制约关系
1. 直接相互制约关系
    - 多个进程需要相互协作共同完成一个任务
    - 在时序上有一定先后关系
    - 如果协作进程的某个操作没有完成，剩下的进程就会自愿等待这个动作完成，成为**进程合作**

2. 间接相互制约关系
    - 竞争同一资源时，该资源同时也只允许被一个资源调度
    - 发生相互排斥，成为**进程互斥**

##硬件同步
- 临界区问题：上锁开锁（避免竞争）
1. 关中断
2. Test And Set

    ```
    boolean TestAndSet(boolean *lock){
        boolean temp = *lock;//获取lock的内容（真/假）
        *lock = True;//锁门
        return temp;//空就是返回false，不空返回true
    }
    do {
        while（Test And Set（&lock));//返回真就一直锁门，直到返回假
             lock = False;//把门打开
        }while(True);
    ```
此种方式在临界区资源忙碌的时候，其他访问进程必须不断尝试
另外，等待进入临界区的进程还可能出现死锁/饥饿
##信号量机制
1. 整形信号量
    1. wait(s)
    ```
    void wait(s){
        while (s<=0);//do nothing
        s--;
    }
    
    ```
    2. signal(s)
    ```
    void signal(s){
        s++;
    }
    ```
1. 记录型信号量
    2. wait(s)
    ```
    s < 0 //意味着前面还有线程
        block(s.queue）//注入阻塞等待队列
    else s-- // 资源空间减少
    ```
    2. signal(s)
    ```
    s++ //资源空间释放
    s <= 0 //意味着等待队列里有元素
        wakeup(s.queue)//将等待队首唤醒加入线程
    ```
    wait(s)：信号量减少1，若s<=0,则将调用它的线程设置成信号量s的状态
    signal(s): 将信号量s加1，若s<=0,则是放一个等待信号量s的进程

4. 小结

    5. 若信号量s.value为正数，比如为2，说明还有2个资源才被阻塞
    6. **s.value == 阻塞队列+可以执行的线程数。**
    6. 若为负数，比如-1，说明现在正在被阻塞，且有一个线程正在等待唤醒
    7. 每次wait（），能执行就执行，不能执行就注入阻塞等待队列，s都减一
    8. 每次signal（），释放一个临界区的进程，如果s.value小于等于0，就将阻塞队列中的进程唤醒进入临界区


5. 二元信号量

6. 应用
    保证互斥


    



    

